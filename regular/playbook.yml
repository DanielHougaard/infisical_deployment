---
- name: Deploy and setup PostgreSQL and Redis on remote servers
  hosts: all
  become: true
  vars:
    # SSH
    ansible_user: "{{ ssh_user }}"
    ansible_password: "{{ ssh_password }}"
    ansible_become_password: "{{ ssh_sudo_password }}"

    # Postgres details
    postgres_user: "{{ hostvars[groups['postgres_server'][0]]['db_user_username'] }}"
    postgres_password: "{{ hostvars[groups['postgres_server'][0]]['db_user_password'] }}"
    postgres_db: "{{ hostvars[groups['postgres_server'][0]]['db_name'] }}"

    postgres_allowed_ip_addresses: "{{ hostvars[groups['postgres_server'][0]]['allowed_ip_addresses'] | default([]) }}"
    postgres_clean_allowed_ip_addresses: "{{ hostvars[groups['postgres_server'][0]]['clean_allowed_ip_addresses'] | default(false) }}"

    # Redis details
    redis_username: "{{ hostvars[groups['redis_server'][0]]['redis_username'] }}"
    redis_password: "{{ hostvars[groups['redis_server'][0]]['redis_password'] }}"

    # Versions
    postgres_version: "{{ hostvars[groups['postgres_server'][0]]['postgres_version'] | default('16') }}"

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Ensure all necessary packages are installed on PostgreSQL server
      apt:
        name:
          - software-properties-common
          - postgresql-{{ postgres_version }}
          - postgresql-client-{{ postgres_version }}
          - postgresql-contrib-{{ postgres_version }}
        state: present
        update_cache: yes
      when: "'postgres_server' in group_names"

    - name: Ensure PostgreSQL service is enabled and started
      systemd:
        name: postgresql
        enabled: yes
        state: started
      when: "'postgres_server' in group_names"

    - name: Set PostgreSQL to listen on all addresses
      lineinfile:
        path: /etc/postgresql/{{ postgres_version }}/main/postgresql.conf
        regexp: "^#?listen_addresses ="
        line: "listen_addresses = '*'"
        state: present
      when: "'postgres_server' in group_names"

    - name: Allow PostgreSQL client authentication
      block:
        - name: Remove all custom IP address entries
          lineinfile:
            path: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
            regexp: '^host\s+all\s+all\s+\d+\.\d+\.\d+\.\d+/32\s+md5$'
            state: absent
          when: postgres_clean_allowed_ip_addresses | bool

        - name: Allow local PostgreSQL connections
          lineinfile:
            path: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
            line: "local   all             postgres                                peer"
            insertbefore: BOF
            state: present

        - name: Allow local IPv4 connections
          lineinfile:
            path: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
            line: "host    all             all             127.0.0.1/32            md5"
            insertafter: "local   all             postgres                                peer"
            state: present

        - name: Allow PostgreSQL client authentication from specific IPs
          lineinfile:
            path: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
            line: "host    all             all             {{ item }}/32               md5"
            state: present
          loop: "{{ postgres_allowed_ip_addresses }}"
          when: postgres_allowed_ip_addresses | length > 0

        - name: Allow PostgreSQL client authentication from anywhere
          lineinfile:
            path: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
            line: "host    all             all             0.0.0.0/0               md5"
            state: present
          when: postgres_allowed_ip_addresses | length == 0
      when: "'postgres_server' in group_names"

    - name: Restart PostgreSQL to apply changes
      systemd:
        name: postgresql
        state: restarted
      when: "'postgres_server' in group_names"

    - name: Install PostgreSQL Python library
      apt:
        name: python3-psycopg2
        state: present
      when: "'postgres_server' in group_names"

    - name: Create PostgreSQL user without privileges
      become_user: postgres
      postgresql_user:
        name: "{{ postgres_user }}"
        password: "{{ postgres_password }}"
        state: present
      when: "'postgres_server' in group_names"

    - name: Create PostgreSQL database
      become_user: postgres
      postgresql_db:
        name: "{{ postgres_db }}"
        owner: "{{ postgres_user }}"
      when: "'postgres_server' in group_names"

    - name: Grant all privileges on database to user
      become_user: postgres
      postgresql_privs:
        db: "{{ postgres_db }}"
        role: "{{ postgres_user }}"
        privs: ALL
        type: database
      when: "'postgres_server' in group_names"

    - name: Open PostgreSQL port in firewall
      ufw:
        rule: allow
        port: 5432
        proto: tcp
      when: "'postgres_server' in group_names"

    - name: Ensure all necessary packages are installed on Redis server
      apt:
        name:
          - software-properties-common
          - redis-server
        state: present
        update_cache: yes
      when: "'redis_server' in group_names"

    - name: Ensure Redis service is enabled and started
      systemd:
        name: redis-server
        enabled: yes
        state: started
      when: "'redis_server' in group_names"

    - name: Configure Redis to listen on all addresses and set password
      lineinfile:
        path: /etc/redis/redis.conf
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        state: present
      loop:
        - { regexp: "^#?bind ", line: "bind 0.0.0.0" }
        - { regexp: "^#?protected-mode ", line: "protected-mode no" }
        - {
            regexp: "^#?requirepass ",
            line: "requirepass {{ redis_password }}",
          }
      when: "'redis_server' in group_names"

    - name: Configure Redis ACL for username and password
      lineinfile:
        path: /etc/redis/redis.conf
        line: "user {{ redis_username }} on >{{ redis_password }} ~* &* +@all"
        state: present
      when: "'redis_server' in group_names"

    - name: Restart Redis to apply changes
      systemd:
        name: redis-server
        state: restarted
      when: "'redis_server' in group_names"

    - name: Open Redis port in firewall
      ufw:
        rule: allow
        port: 6379
        proto: tcp
      when: "'redis_server' in group_names"

- name: Wait for PostgreSQL and Redis setup to complete
  hosts: localhost
  tasks:
    - meta: flush_handlers

- name: Get PostgreSQL server connection URL
  hosts: postgres_server
  vars:
    # SSH
    ansible_user: "{{ ssh_user }}"
    ansible_password: "{{ ssh_password }}"
    ansible_become_password: "{{ ssh_sudo_password }}"

  tasks:
    - name: Set PostgreSQL connection URL
      set_fact:
        postgres_connection_url: "postgresql://{{ hostvars[inventory_hostname]['db_user_username'] }}:{{ hostvars[inventory_hostname]['db_user_password'] | urlencode }}@{{ ansible_default_ipv4.address }}:5432/{{ hostvars[inventory_hostname]['db_name'] }}"

- name: Get Redis server connection URL
  hosts: redis_server
  vars:
    # SSH
    ansible_user: "{{ ssh_user }}"
    ansible_password: "{{ ssh_password }}"
    ansible_become_password: "{{ ssh_sudo_password }}"
  tasks:
    - name: Set Redis connection URL
      set_fact:
        redis_connection_url: "redis://{{ hostvars[inventory_hostname]['redis_username'] }}:{{ hostvars[inventory_hostname]['redis_password'] | urlencode }}@{{ ansible_default_ipv4.address }}:6379"

- name: Set up Infisical server
  hosts: infisical_instance
  become: true
  vars:
    # SSH
    ansible_user: "{{ ssh_user }}"
    ansible_password: "{{ ssh_password }}"
    ansible_become_password: "{{ ssh_sudo_password }}"

  tasks:
    # Create directory if not already present
    - name: Create Infisical configuration directory
      file:
        path: /etc/infisical
        state: directory
        mode: "0755"

    # Create environment if not already present
    - name: Create Infisical environment file
      file:
        path: /etc/infisical/environment
        state: touch
        mode: "0600"

    # Check if the ENCRYPTION_KEY variable is set.
    - name: Check if ENCRYPTION_KEY exists
      command: grep -q '^ENCRYPTION_KEY=' /etc/infisical/environment
      register: encryption_key_exists
      changed_when: false
      failed_when: false

    # C Check if the AUTH_SECRET variable is set.
    - name: Check if AUTH_SECRET exists
      command: grep -q '^AUTH_SECRET=' /etc/infisical/environment
      register: auth_secret_exists
      changed_when: false
      failed_when: false

    # Generate ENCRYPTION_KEY to use if it doesn't exist.
    - name: Generate ENCRYPTION_KEY if it doesn't exist
      shell: openssl rand -hex 16
      register: generated_encryption_key
      when: encryption_key_exists.rc != 0

    # Generate AUTH_SECRET to use if it doesn't exist.
    - name: Generate AUTH_SECRET if it doesn't exist
      shell: openssl rand -base64 32
      register: generated_auth_secret
      when: auth_secret_exists.rc != 0

    # Add ENCRYPTION_KEY variable if it isn't set
    - name: Add ENCRYPTION_KEY to environment file
      lineinfile:
        path: /etc/infisical/environment
        line: "ENCRYPTION_KEY={{ generated_encryption_key.stdout }}"
        state: present
      when: encryption_key_exists.rc != 0

    # Add AUTH_SECRET variable if it isn't set
    - name: Add AUTH_SECRET to environment file
      lineinfile:
        path: /etc/infisical/environment
        line: "AUTH_SECRET={{ generated_auth_secret.stdout }}"
        state: present
      when: auth_secret_exists.rc != 0

    # Set DB_CONNECTION_URI from the postgres instance
    - name: Set DB_CONNECTION_URI environment variable
      lineinfile:
        path: /etc/infisical/environment
        line: "DB_CONNECTION_URI={{ hostvars[groups['postgres_server'][0]]['postgres_connection_url'] }}"
        state: present

    # Set REDIS_URL to the URL from the redis instance
    - name: Set REDIS_URL environment variable
      lineinfile:
        path: /etc/infisical/environment
        line: "REDIS_URL={{ hostvars[groups['redis_server'][0]]['redis_connection_url'] }}"
        state: present

    # Set permissions for env file, current user can read and write the file or directory and other users have no access to it
    - name: Set permissions for Infisical environment file
      file:
        path: /etc/infisical/environment
        mode: "0600"

    - name: Create wrapper script for running custom env
      copy:
        content: |
          #!/bin/bash
          set -a
          source /etc/infisical/environment
          set +a
          exec "$@"
        dest: /usr/local/bin/run_with_env
        mode: "0755"

    - name: Install Infisical from .deb package
      ansible.builtin.shell:
        cmd: curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-standalone/cfg/setup/bash.deb.sh' | sudo bash && sudo apt-get install -y infisical-standalone
      args:
        executable: /bin/bash
      become: true

    # During the setup, we need to run the migrations
    - name: Execute Postgres migrations
      shell: |
        source /etc/infisical/environment
        /usr/local/bin/run_with_env infisical-standalone migration:latest
      args:
        executable: /bin/bash
      register: migration_result
      changed_when: migration_result.rc == 0
      failed_when: migration_result.rc != 0

    # Create a system demon for Infisical
    - name: Create Infisical systemd service file
      template:
        src: infisical.service.j2
        dest: /etc/systemd/system/infisical.service
      notify: Reload systemd

    # Start and enable the service
    - name: Ensure Infisical service is enabled and started
      systemd:
        name: infisical
        enabled: yes
        state: started

    # Restart the service just to make sure we got the latest state possible
    - name: Restart Infisical service
      systemd:
        name: infisical
        state: restarted

    - name: Install HAProxy
      apt:
        name: haproxy
        state: present
        update_cache: yes

    - name: Configure HAProxy
      template:
        src: haproxy.cfg.j2
        dest: /etc/haproxy/haproxy.cfg
      notify: Reload HAProxy

    - name: Format HAProxy configuration
      shell: echo "" >> /etc/haproxy/haproxy.cfg

    - name: Ensure HAProxy service is enabled and started
      systemd:
        name: haproxy
        enabled: yes
        state: started

    - name: Open HTTP port in firewall
      ufw:
        rule: allow
        port: "80"
        proto: tcp

  handlers:
    - name: Reload systemd
      systemd:
        daemon_reload: yes

    - name: Reload HAProxy
      systemd:
        name: haproxy
        state: reloaded
